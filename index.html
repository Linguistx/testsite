<html>

<meta charset="UTF-8">
<link href="/theme/default.css" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Cinzel&display=swap" rel="stylesheet">
	<script src="https://cdn.jsdelivr.net/npm/showdown@1.9.0/dist/showdown.min.js"></script>
<body>
    <article>
        <div class="header">
            <span id="#logo-title">
		<a class="title-home-link" href="./"><img src="/theme/logo.svg" class="logo" height="70"></img></a>
                <span id="title-box"></span>
            </span>
            <span class="searchbar">
                <span id="searchPart">
                    <input id="search-box-input" autocorrect="off" autocapitalize="off" spellcheck="false" onfocus="border('on')" onblur="border('off')"></input>
                    <img onclick="javascript:searchWord()" id="magnifying-glass" class="pointer" src="/theme/magnifying-glass.svg" height="25px"></img>
                </span>
            </span>
        </div>
        <div class="navbar">
            <a href="./">HOME</a>
            <a class="pointer" onclick="sendEntry('grammar-doc')">GRAMMAR</a>
        </div>
        <div class="row">
            <div class="side" id="sidebar"></div>
            <div class="main">
		    <div id="tab-space"></div>
                <div id="entry"></div>
            </div>
        </div>
        <div class="footer">
            <a class="title-home-link" href="https://www.vulgarlang.com">Powered by Vulgarlang.com</a> | 
            Icons made by <a class="title-home-link" href="https://www.flaticon.com/authors/freepik" title="Freepik">Freepik</a> 
            from <a class="title-home-link" href="https://www.flaticon.com/" title="Flaticon">www.flaticon.com</a>
        </div>
    </article>
</body>

<script>
let url = document.location.href;
let textFileLocation = document.location.origin + '/dictionary.txt';

let settings = {
    title : 'A Vulgar Online Dictionry',
    languageA : '',
    languageB : '',
    exonymA : '',
    exonymb : ''
}

let partsOfSpeech = {};
let dictionaryA = {};
let dictionaryB = {};
let AentriesOnly = [];
let BentriesOnly = [];
let headingPattern = /(\w+ *:)/g;
tryLang = 'A';

let getTextFile = new XMLHttpRequest();
getTextFile.open('GET', textFileLocation, true);
getTextFile.send();
    
getTextFile.onreadystatechange = function() {
    if (getTextFile.readyState == 4 && getTextFile.status == 200) {
        
        let dictionaryBlob = getTextFile.responseText;
        dictionaryBlob = dictionaryBlob.split(/--- *(SETTINGS|PARTS OF SPEECH|A TO B DICTIONARY|B TO A DICTIONARY)/g);

        let settingsText = dictionaryBlob[dictionaryBlob.indexOf('SETTINGS') + 1];
        let partsOfSpeechText = dictionaryBlob[dictionaryBlob.indexOf('PARTS OF SPEECH') + 1];
        let dictionaryAtext = dictionaryBlob[dictionaryBlob.indexOf('A TO B DICTIONARY') + 1];
        let dictionaryBtext = dictionaryBlob[dictionaryBlob.indexOf('B TO A DICTIONARY') + 1];
        
        settingsText = settingsText.split(/\n/g)
        for (let setting of settingsText) {
            setting = setting.trim();
            if (setting == '') continue;
            setting = setting.split('=');
            let keySide = setting[0].trim();
            let valueSide = setting[1].trim();
            switch (keySide) {
                case 'Website title': settings.title = valueSide; break;
                case 'Language A': settings.languageA = valueSide; break;
                case 'Language B': settings.languageB = valueSide; break;
                case 'Exonym A': settings.exonymA = valueSide; break;
                case 'Exonym B': settings.exonymB = valueSide; break;
            }            
        }
        document.getElementById('title-box').innerHTML = '<a class="title-home-link" href="./">' + settings.title.toUpperCase() + '</a>'
	+ '<p class="powered"><a class="title-home-link" href="https://www.vulgarlang.com">Powered by Vulgarlang.com</a></p>';
        document.title = settings.title;
        
        partsOfSpeechText = partsOfSpeechText.split('\n')
        for (let line of partsOfSpeechText) {
            line = line.trim()
            if (line == '' || !line.includes('=')) continue;
            line = line.split('=');
            let keySide = line[0].trim();
            let valueSide = line[1].trim();
            partsOfSpeech[keySide] = valueSide;
        }   
        
        dictionaryAtext = dictionaryAtext.split('#');
        for (let entry of dictionaryAtext) {
            let forwardSlash = entry.indexOf('/');
            let colon = entry.search(/\w+ *:/);
            let delineator = Math.min(forwardSlash, colon);
            delineator = (delineator > 0) ? delineator : Math.max(forwardSlash, colon);
            let word = entry.slice(0, delineator).trim();
            let wordData = entry.slice(delineator).trim();
            if (!dictionaryA[word]) {
                dictionaryA[word] = [wordData];
                AentriesOnly.push(word);
            } else {
                dictionaryA[word].push(wordData);
            }
        }
		
        dictionaryBtext = dictionaryBtext.split('#');
        for (let entry of dictionaryBtext) {
            let forwardSlash = entry.indexOf('/');
            let colon = entry.search(/\w+ *:/);
            let delineator = Math.min(forwardSlash, colon);
            delineator = (delineator > 0) ? delineator : Math.max(forwardSlash, colon);
            let word = entry.slice(0, delineator).trim();
            let wordData = entry.slice(delineator).trim();
            if (!dictionaryB[word]) {
                dictionaryB[word] = [wordData];
                BentriesOnly.push(word);
            } else {
                dictionaryB[word].push(wordData);
            }
        }
        
        if (url.endsWith('/?grammar-doc')) {
            sendEntry('grammar-doc');
        } else if (url.includes('?')) {
            var queryTerm = decodeURI(url.slice(url.indexOf('?') + 1));
            sendEntry(queryTerm, dictionaryA[queryTerm], dictionaryB[queryTerm]);
        }
    }
}

function sendEntry(term, associatedInfoA, associatedInfoB) {
    if (term == 'grammar-doc') {
        document.getElementById('tab-space').innerHTML = '';
        document.getElementById('entry').innerHTML = '';
        var stateObj = { foo: 'bar' };
        history.pushState(stateObj, term, '?grammar-doc');
        var converter = new showdown.Converter();
        let grammarFileLocation = document.location.origin + '/grammar.txt';
        let getGrammarFile = new XMLHttpRequest();
        getGrammarFile.open('GET', grammarFileLocation, true);
        getGrammarFile.send();
        converter.setOption('tables', true);

        getGrammarFile.onreadystatechange = function() {
            if (getGrammarFile.readyState == 4 && getGrammarFile.status == 200) {
		let grammarBlob = getGrammarFile.responseText;
		document.getElementById('entry').innerHTML = converter.makeHtml(grammarBlob);
		return;
            }
	}
    }
    let bothLanguage = '';
    if (!associatedInfoA && !associatedInfoB && term != 'grammar-doc') {
        document.getElementById('entry').innerHTML = 'No entry found';
	return;
    } else if (associatedInfoA && associatedInfoB) {
        if (tryLang == 'A') {
            bothLanguage = '<div class="tab-holder"><span>' + settings.languageB + ' to ' + settings.languageA + '</span> '
		+ '<span class="tab">' + settings.languageA + ' to ' + settings.languageB + '</span></div>';
            var chosenLang = associatedInfoA;
            var chosenLangEntries = AentriesOnly;
        } else {
            bothLanguage = '<div class="tab-holder"><span class="tab">' + settings.languageB + ' to ' + settings.languageA + '</span> '
		+ '<span>' + settings.languageA + ' to ' + settings.languageB + '</span></div>';
            var chosenLang = associatedInfoB;
            var chosenLangEntries = BentriesOnly;
        }
    } else if (associatedInfoA) {
        var chosenLang = associatedInfoA;
        var chosenLangEntries = AentriesOnly
        tryLang = 'A';
    } else if (associatedInfoB) {
        var chosenLang = associatedInfoB;
        var chosenLangEntries = BentriesOnly;
        tryLang = 'B';
    }
	
    let allEntries = [];
    for (let entry of chosenLang) {
        let subheadings = [];
        let locationsOfNewHeading = [];
	let pronunciation = entry.trim().match(/\/.*?\//);
        let match;
        while (match = headingPattern.exec(entry)) {
            locationsOfNewHeading.push(match.index)
        }	    
        for (let i = 0; i < locationsOfNewHeading.length; i++) {
            var translations = [];
            let end = locationsOfNewHeading[i + 1];
            if (!end) {
                end = entry.length;
            }
            let section = entry.slice(locationsOfNewHeading[i], end);
            let del = section.search(/:/);
            let head = section.slice(0, del);
            let body = section.slice(del + 1, section.length).trim();
            if (partsOfSpeech[head]) {
                head = '<h3>' + partsOfSpeech[head] + '</h3>';
                let offset = body.search(/\d+\./) > -1 ? 1 : 0; 
                body = body.split(/\d+\./);
                var translation = '';
                for (let j = offset; j < body.length; j++) {
                    let sense = body[j];
                    sense = sense.split('*');
                    var translation = '<li>' + sense[0].trim() + '</li>';
                    let quotes = '';
                    for (let k = 1; k < sense.length; k++) {
                        let quote = '<li>' + sense[k].trim() + '</li>';
                        if (quote.includes(' - ')) {
                            quote = quote.replace(' - ', ' â€” <span class="trans-quote">');
                            quote = quote.replace('</li>', '</span></li>');
                        }
                        quotes += quote;
                    }
                    if (quotes != "") quotes = '<ul class="quotes">' + quotes + '</ul>'
                        translation += quotes;
                        translations.push(translation);
                    }
                
                    if (translation != []) translation = '<ol>' + translations.join("") + '</ol>';
                    section =  head + translation;
		} else {
                    head = '<h2>' + head.replace(/_/g, ' ') + '</h2>' ;    
                    section = head + body;
		}
            subheadings.push(section);
        }    

        var final = '<h1>' + term + '</h1>' + '<p>' + pronunciation + '</p>' + subheadings.join('');
        allEntries.push(final);
    }
    document.getElementById('tab-space').innerHTML = bothLanguage;
    document.getElementById('entry').innerHTML = allEntries.join('');

    let startIndex = chosenLangEntries.indexOf(term);
    if (startIndex < 10) startIndex = 10;
    var sidebar = chosenLangEntries.slice(startIndex - 10 , startIndex + 11);
    sidebar = sidebar.map(i => `<li><a onclick="javascript:sendEntry('` + i + `', dictionaryA['` + i + `'], dictionaryB['` + i + `']);">` + i + '</a></li>');
    document.getElementById('sidebar').innerHTML = '<h3>More ...</h3><ul>' + sidebar.join('') + '</ul>';
    var stateObj = { foo: 'bar' };
    history.pushState(stateObj, term, '?' + term);
}

function searchWord() {
    let queryTerm = document.getElementById('search-box-input').value.trim();
    sendEntry(queryTerm, dictionaryA[queryTerm], dictionaryB[queryTerm]);
    var stateObj = { foo: 'bar' };
    history.pushState(stateObj, queryTerm, '?' + queryTerm);
}

let input = document.getElementById('search-box-input')
input.addEventListener('keyup', function(event) {
    if (event.keyCode === 13) {
        event.preventDefault();
        document.getElementById('magnifying-glass').click();
    }
})
	
function border(x) {
    if (x == 'on') {
        document.getElementById("searchPart").style.cssText = "border: 2px solid #1c3448; padding: 6px 6px 6px 9px;";
    } else {
	 document.getElementById("searchPart").style.cssText = "border: none; padding: 8px 8px 8px 11px;";   
    }
}
   
</script>
    
</html>
